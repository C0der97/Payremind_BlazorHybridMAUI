@page "/"
@inject NotificationServiceBd NotificationServiceBd
@inject NotificationServiceMaui NotificationServiceMaui
@inject SQLiteDatabaseService DatabaseService
@inject IJSRuntime JSRuntime
@inject SharedStateService StateService
@inject IJSRuntime JS
@inject IDialogService DialogService
@inject ISnackbar Snackbar
@implements IDisposable


@using Maui.NullableDateTimePicker
@using PayRemind.Shared
@using Plugin.LocalNotification
@using Microsoft.Extensions.DependencyInjection


<MudThemeProvider @bind-IsDarkMode="@_isDarkMode" />
<MudPopoverProvider />
<MudDialogProvider Position="DialogPosition.TopCenter" />
<MudSnackbarProvider />

<style>
    .swipe-item {
        position: relative;
        overflow: hidden;
        touch-action: pan-y;
    }

    .swipe-actions {
        position: absolute;
        right: -150px;
        top: 0;
        height: 100%;
        display: flex;
        transition: transform 0.3s ease;
    }

    .swipe-action {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 100%;
        color: white;
    }
</style>

@foreach (var item in Items)
{
    <MudPaper Class="pa-4 my-4" Elevation="3">
        <MudCard>
            <MudCardContent>
                <MudText Typo="Typo.h5">@item.Title</MudText>
                <MudText Typo="Typo.body2">@item.DateNotification</MudText>
                <MudText Typo="Typo.body2">
                    Estado: <strong>@(item.IsPaid ? "Pagado" : "Sin Pagar")</strong>
                </MudText>
            </MudCardContent>
            @if (!item.IsPaid)
            {
                <MudCardActions>
                    <MudIconButton Icon="@Icons.Material.Filled.Edit"
                                   Color="Color.Info"
                                   OnClick="() => EditItem(item)" />
                    <MudIconButton Icon="@Icons.Material.Filled.Cached"
                                   Color="Color.Default"
                                   OnClick="() => RescheduleNotification(item)" />
                    <MudIconButton Icon="@Icons.Material.Filled.Done"
                                   Color="Color.Success"
                                   OnClick="() => MarAsPayed(item)" />
                    <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                   Color="Color.Error"
                                   OnClick="() => DeleteItem(item)" />
                </MudCardActions>
            }
        </MudCard>
    </MudPaper>
}


<MudIconButton Icon="@Icons.Material.Filled.Add" 
Variant="Variant.Filled"
               OnClick="OpenDialogAsync"
               Size="Size.Large"
               Style=@($"position: fixed;right: 20px; bottom: 20px; z-index: 100%;border-radius:50%;background-color:#3dc4a4;color:white")></MudIconButton>



@code {

    AppTheme currentTheme = Application.Current.RequestedTheme;

    private NotificationData notificationData = new NotificationData();

    private List<NotificationData> notifications = new();
    private NotificationData selectedNotification = new();
    private List<SwipeItemNotification> Items = new List<SwipeItemNotification>();

    private bool _isDarkMode;

    public DateTime datePart { get; set; } = DateTime.Now.Date;
    public TimeSpan timePart { get; set; } = DateTime.Now.TimeOfDay;

    public string timePartString
    {
        get => timePart.ToString(@"hh\:mm");
        set
        {
            if (TimeSpan.TryParse(value, out TimeSpan parsedTime))
            {
                timePart = parsedTime;
            }
        }
    }

    NullableDateTimePicker dateTimePicker = new NullableDateTimePicker();

    private static void OnNullableDateTimeChanged(object sender, DateTimeChangedEventArgs e)
    {
        Console.WriteLine("DateTime changed!");
        Console.WriteLine("Old DateTime: " + e.OldDateTime);
        Console.WriteLine("New DateTime: " + e.NewDateTime);
    }

    protected override async Task OnInitializedAsync()
    {
        if (currentTheme == AppTheme.Light)
        {
            _isDarkMode = false;
        }
        else
        {
            _isDarkMode = true;
        }

        if (await LocalNotificationCenter.Current.AreNotificationsEnabled() == false)
        {
            await LocalNotificationCenter.Current.RequestNotificationPermission();
        }

        await Permissions.RequestAsync<Permissions.Phone>();
        // await Permissions.RequestAsync<Permissions.ContactsRead>();
        await Permissions.RequestAsync<Permissions.Reminders>();
        await Permissions.RequestAsync<Permissions.Speech>();
        await Permissions.RequestAsync<Permissions.Battery>();


        dateTimePicker.NullableDateTimeChanged += OnNullableDateTimeChanged;

        notifications = await DatabaseService.GetNotificationsAsync(false);

        ReloadItems();

        StateService.OnChange += StateHasChangedData;

    }

    void ReloadItems()
    {
        Items.Clear();

        foreach (var not in notifications)
        {

            Items.Add(new SwipeItemNotification
                {
                    Id = not.Id,
                    Title = not.Name,
                    IsPaid = not.IsPaid,
                    DateNotification = not.DateTime.ToString("yyyy-MM-dd hh:mm tt")
                });
        }
    }


    async Task OpenCalendar()
    {
        StateHasChanged();

        INullableDateTimePickerOptions nullableDateTimePickerOptions = new NullableDateTimePickerOptions
            {
                NullableDateTime = DateTime.Now,
                Mode = PickerModes.DateTime,
                ShowWeekNumbers = true
            };

        var result = await NullableDateTimePicker.OpenCalendarAsync(nullableDateTimePickerOptions);

        if (result is PopupResult popupResult && popupResult.ButtonResult != PopupButtons.Cancel)
        {
            var MyDateTime = popupResult.NullableDateTime;
            datePart = MyDateTime?.Date ?? DateTime.Now.Date;
            timePart = MyDateTime?.TimeOfDay ?? DateTime.Now.TimeOfDay;
            Console.WriteLine("Fecha: " + MyDateTime.ToString());
        }

        StateHasChanged();
    }






    private void UpdateTimePart(ChangeEventArgs e)
    {
        timePartString = e.Value.ToString();
    }

    async Task<bool> MarAsPayed(SwipeItemNotification item)
    {
        selectedNotification = notifications.Where((x) => x.Id == item.Id).FirstOrDefault() ?? new NotificationData();

        bool answer = await Application.Current.MainPage.DisplayAlert("Confirmación", "¿Estás seguro que deseas realizar esta acción?", "Sí", "No");

        if (answer == true)
        {
            selectedNotification.IsPaid = true;

            await DatabaseService.SaveNotificationAsync(selectedNotification, true);

            notifications = await DatabaseService.GetNotificationsAsync(false);

            int[] cancelIds = [selectedNotification.NotificationId];
            var resultCancel = LocalNotificationCenter.Current.Cancel(cancelIds);

            var pending = await LocalNotificationCenter.Current.GetPendingNotificationList();

            StateService.NotifyStateChanged();

            ReloadItems();

        }

        return await Task.FromResult(true);
    }

    async Task<bool> RescheduleNotification(SwipeItemNotification item)
    {
        selectedNotification = notifications.Where((x) => x.Id == item.Id).FirstOrDefault() ?? new NotificationData();


        bool answer = await Application.Current.MainPage.DisplayAlert("Confirmación", "¿Estás seguro que deseas realizar esta acción?", "Sí", "No");

        if (answer == true)
        {
            // Si el usuario confirma, programamos una nueva notificación para el próximo mes
            selectedNotification.IsPaid = false;
            selectedNotification.DateTime = selectedNotification.DateTime.AddDays(30);
            selectedNotification.Id = 0;

            int result = await DatabaseService.SaveNotificationAsync(selectedNotification, false);

            notifications = await DatabaseService.GetNotificationsAsync(false);

            StateService.NotifyStateChanged();


            ReloadItems();
        }



        return await Task.FromResult(true);
    }




    private async Task TouchStart(TouchEventArgs e, SwipeItemNotification item)
    {
        if (!item.IsPaid)
        {
            item.StartX = e.Touches[0].ClientX;
        }

    }

    private async Task TouchMove(TouchEventArgs e, SwipeItemNotification item)
    {
        if (!item.IsPaid)
        {
            var currentX = e.Touches[0].ClientX;
            var diff = item.StartX - currentX;

            if (diff > 0 && diff <= 200)
            {
                await JSRuntime.InvokeVoidAsync("eval", $"document.querySelector('[_bl_{item.ElementReference.Id}] .swipe-actions').style.transform = 'translateX(-{diff}px)'");
            }

        }
    }

    private async Task TouchEnd(SwipeItemNotification item)
    {
        if (!item.IsPaid)
        {
            await JSRuntime.InvokeVoidAsync("eval", $"document.querySelector('[_bl_{item.ElementReference.Id}] .swipe-actions').style.transform = 'translateX(-150px)'");

        }
    }

    private void EditItem(SwipeItemNotification item)
    {
        // Lógica para editar el item
        Console.WriteLine($"Editando item {item.Id}");
    }

    private async Task DeleteItem(SwipeItemNotification item)
    {
        var notification = new NotificationData()
            {
                Id = item.Id
            };

        await DatabaseService.DeleteNotificationAsync(notification);
        int[] cancelIds = [notification.NotificationId];
        LocalNotificationCenter.Current.Cancel(cancelIds);


        Items.Remove(item);
        StateHasChanged();
    }    

    private Task OpenDialogAsync()
    {
        return DialogService.ShowAsync<DialogSetOptionsExample_Dialog>("Nuevo Recordatorio");
    }

    async Task StateHasChangedData()
    {
        await ReloadData();
        ReloadItems();
        StateHasChanged();
    }

    async Task ReloadData()
    {
        notifications = await DatabaseService.GetNotificationsAsync(false);
    }

    public void Dispose()
    {
        StateService.OnChange -= StateHasChangedData;
    }

}
